

when a cycle (v_0,...v_k) is contracted, all cycle edges cost 0
We have to remove one of those edges, but do not know which one to remove yet
The contraction means, that we defer the decision which of those 0 edges we want to throw out until later
when the cheapest incoming edge into the cycle (x, y) [here x,y represent original/uncontracted nodes] is picked, we know that y is (or is contained in) some cycle node v_i

the right choice would be to throw away the cycle edge incoming to v_i aka (v_{i-1}, v_i) and replace it with (x,y)
the edge (v_{i-1}, v_i) is at this point stored in $\pi[v_i]$ 
however, when contracting we chose some arbitrary node $v_r$ to represent the cycle and will save the edge (x,y) into \pi[v_r]
v_r is not necessarily the same as v_i
this node v_r also has some cycle edge saved in \pi[v_r] that will be mistakenly overwritten


the idea for reconstruction is to save some information when contracting each cycle and then fix these mistaken overrides (from last cycle to first)
such that \pi[v] contains the incoming arborescence edge of each node in the end

all we need is the following
for each cycle we save the previous value of \pi[v_r] along with v_r
when a cycle is processed, the incoming edge into the cycle is saved in pi[v_r] = (x,y)
we then have to determine v_i
we know that the DSU could tell us v_i as the representative of y when the cycle was contracted
so we just need a persistent DSU that can answer queries like 'what was the rep of node y after the first x contractions'
thus we find v_i, write pi[v_r] = (x,y) into pi[v_i] (thus overriding the not needed cycle edge), and then restore pi[v_r] with the meta-info we saved for each cycle



